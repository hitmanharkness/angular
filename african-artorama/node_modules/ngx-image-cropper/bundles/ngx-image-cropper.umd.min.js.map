{"version":3,"sources":["ng://ngx-image-cropper/src/functions/image.functions.ts","ng://ngx-image-cropper/src/component/image-cropper.component.ts","ng://ngx-image-cropper/src/image-cropper.module.ts"],"names":["resetExifOrientation","srcBase64","exifRotation","getExifRotation","imageBase64","view","DataView","base64ToArrayBuffer","replace","binaryString","atob","len","length","bytes","Uint8Array","i","charCodeAt","buffer","getUint16","byteLength","offset","marker","getUint32","little","tags","rotateBase64BasedOnExifRotation","Promise","resolve","reject","img","Image","onload","width","height","canvas","document","createElement","ctx","getContext","transformCanvas","orientation","transform","drawImage","toDataURL","Error","src","ex","ImageCropperComponent","sanitizer","cd","zone","this","x1","y1","x2","y2","EventEmitter","initCropper","Object","defineProperty","prototype","file","loadImageFile","event","target","files","loadBase64Image","ngOnChanges","changes","_this","setTimeout","setMaxSize","checkCropperPosition","doAutoCrop","markForCheck","imageVisible","resetCropperPosition","originalImage","safeImgDataUrl","moveStart","active","type","position","clientX","clientY","maxSize","originalSize","cropper","fileReader","FileReader","imageType","isValidImageType","result","then","resultBase64","catch","loadImageFailed","emit","readAsDataURL","test","bypassSecurityTrustResourceUrl","imageLoadedInView","imageLoaded","onResize","resizeCropperPosition","sourceImageElement","sourceImage","nativeElement","offsetWidth","offsetHeight","aspectRatio","cropperHeight","cropperWidth","startMove","moveType","assign","getClientX","getClientY","moveImg","stopPropagation","preventDefault","move","resize","detectChanges","marginLeft","bypassSecurityTrustStyle","maintainSize","moveStop","diffX","diffY","Math","min","max","maintainAspectRatio","checkAspectRatio","overflowX","overflowY","autoCrop","crop","startCropImage","ratio","left","round","top_1","resizeRatio","getResizeRatio","resizedWidth","floor","resizedHeight","cropCanvas","cropToOutputType","output","cropperPosition","outputType","cropToFile","imageCropped","base64","cropToBase64","format","getQuality","imageCroppedBase64","getCanvasBlob","imageCroppedFile","toBlob","run","imageQuality","resizeToWidth","onlyScaleDown","touches","Component","args","selector","template","changeDetection","ChangeDetectionStrategy","OnPush","DomSanitizer","ChangeDetectorRef","NgZone","ViewChild","Input","Output","HostListener","ImageCropperModule","NgModule","imports","CommonModule","declarations","exports"],"mappings":"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","sourcesContent":["export function resetExifOrientation(srcBase64: string): Promise<string> {\n    try {\n        const exifRotation = getExifRotation(srcBase64);\n        if (exifRotation > 1) {\n            return rotateBase64BasedOnExifRotation(srcBase64, exifRotation);\n        } else {\n            return Promise.resolve(srcBase64);\n        }\n    } catch (ex) {\n        return Promise.reject(ex);\n    }\n}\n\nfunction rotateBase64BasedOnExifRotation(srcBase64: string, exifRotation: number): Promise<string> {\n    return new Promise((resolve, reject) => {\n        const img = new Image();\n        img.onload = function () {\n            const width = img.width;\n            const height = img.height;\n            const canvas = document.createElement('canvas');\n            const ctx = canvas.getContext('2d');\n\n            if (ctx) {\n                if (4 < exifRotation && exifRotation < 9) {\n                    canvas.width = height;\n                    canvas.height = width;\n                } else {\n                    canvas.width = width;\n                    canvas.height = height;\n                }\n                transformCanvas(ctx, exifRotation, width, height);\n                ctx.drawImage(img, 0, 0);\n                resolve(canvas.toDataURL());\n            } else {\n                reject(new Error('No context'));\n            }\n        };\n        img.src = srcBase64;\n    });\n}\n\nfunction getExifRotation(imageBase64: string): number {\n    const view = new DataView(base64ToArrayBuffer(imageBase64));\n    if (view.getUint16(0, false) != 0xFFD8) {\n        return -2;\n    }\n    const length = view.byteLength;\n    let offset = 2;\n    while (offset < length) {\n        if (view.getUint16(offset + 2, false) <= 8) return -1;\n        const marker = view.getUint16(offset, false);\n        offset += 2;\n        if (marker == 0xFFE1) {\n            if (view.getUint32(offset += 2, false) != 0x45786966) {\n                return -1;\n            }\n\n            const little = view.getUint16(offset += 6, false) == 0x4949;\n            offset += view.getUint32(offset + 4, little);\n            const tags = view.getUint16(offset, little);\n            offset += 2;\n            for (let i = 0; i < tags; i++) {\n                if (view.getUint16(offset + (i * 12), little) == 0x0112) {\n                    return view.getUint16(offset + (i * 12) + 8, little);\n                }\n            }\n        }\n        else if ((marker & 0xFF00) != 0xFF00) {\n            break;\n        }\n        else {\n            offset += view.getUint16(offset, false);\n        }\n    }\n    return -1;\n}\n\nfunction base64ToArrayBuffer(imageBase64: string) {\n    imageBase64 = imageBase64.replace(/^data\\:([^\\;]+)\\;base64,/gmi, '');\n    const binaryString = atob(imageBase64);\n    const len = binaryString.length;\n    const bytes = new Uint8Array(len);\n    for (let i = 0; i < len; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes.buffer;\n}\n\nfunction  transformCanvas(ctx: any, orientation: number, width: number, height: number) {\n    switch (orientation) {\n        case 2:\n            ctx.transform(-1, 0, 0, 1, width, 0);\n            break;\n        case 3:\n            ctx.transform(-1, 0, 0, -1, width, height);\n            break;\n        case 4:\n            ctx.transform(1, 0, 0, -1, 0, height);\n            break;\n        case 5:\n            ctx.transform(0, 1, 1, 0, 0, 0);\n            break;\n        case 6:\n            ctx.transform(0, 1, -1, 0, height, 0);\n            break;\n        case 7:\n            ctx.transform(0, -1, -1, 0, height, width);\n            break;\n        case 8:\n            ctx.transform(0, -1, 1, 0, 0, width);\n            break;\n        default:\n            break;\n    }\n}\n","import {\n    Component, ElementRef, EventEmitter, HostListener, Input, OnChanges, Output, SimpleChanges,\n    ChangeDetectorRef, ChangeDetectionStrategy, NgZone, ViewChild\n} from '@angular/core';\nimport { DomSanitizer, SafeUrl, SafeStyle } from '@angular/platform-browser';\nimport { MoveStart, Dimensions, CropperPosition, ImageCroppedEvent } from '../interfaces';\nimport { resetExifOrientation } from '../functions/image.functions';\n\n@Component({\n    selector: 'image-cropper',\n    templateUrl: './image-cropper.component.html',\n    styleUrls: ['./image-cropper.component.scss'],\n    changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class ImageCropperComponent implements OnChanges {\n    private originalImage: any;\n    private moveStart: MoveStart;\n    private maxSize: Dimensions;\n    private originalSize: Dimensions;\n\n    safeImgDataUrl: SafeUrl | string;\n    marginLeft: SafeStyle | string = '0px';\n    imageVisible = false;\n\n    @ViewChild('sourceImage') sourceImage: ElementRef;\n\n    @Input()\n    set imageFileChanged(file: File) {\n        this.initCropper();\n        if (file) {\n            this.loadImageFile(file);\n        }\n    }\n\n    @Input()\n    set imageChangedEvent(event: any) {\n        this.initCropper();\n        if (event && event.target && event.target.files && event.target.files.length > 0) {\n            this.loadImageFile(event.target.files[0]);\n        }\n    }\n\n    @Input()\n    set imageBase64(imageBase64: string) {\n        this.initCropper();\n        this.loadBase64Image(imageBase64);\n    }\n\n    @Input() format: 'png' | 'jpeg' | 'bmp' | 'webp' | 'ico' = 'png';\n    @Input() outputType: 'base64' | 'file' | 'both' = 'both';\n    @Input() maintainAspectRatio = true;\n    @Input() aspectRatio = 1;\n    @Input() resizeToWidth = 0;\n    @Input() roundCropper = false;\n    @Input() onlyScaleDown = false;\n    @Input() imageQuality = 92;\n    @Input() autoCrop = true;\n    @Input() cropper: CropperPosition = {\n        x1: -100,\n        y1: -100,\n        x2: 10000,\n        y2: 10000\n    };\n\n    @Output() startCropImage = new EventEmitter<void>();\n    @Output() imageCropped = new EventEmitter<ImageCroppedEvent>();\n    @Output() imageCroppedBase64 = new EventEmitter<string>();\n    @Output() imageCroppedFile = new EventEmitter<Blob>();\n    @Output() imageLoaded = new EventEmitter<void>();\n    @Output() loadImageFailed = new EventEmitter<void>();\n\n    constructor(private sanitizer: DomSanitizer,\n                private cd: ChangeDetectorRef,\n                private zone: NgZone) {\n        this.initCropper();\n    }\n\n    ngOnChanges(changes: SimpleChanges): void {\n        if (changes['cropper']) {\n            setTimeout(() => {\n                this.setMaxSize();\n                this.checkCropperPosition(false);\n                this.doAutoCrop();\n                this.cd.markForCheck();\n            });\n        }\n        if (changes['aspectRatio'] && this.imageVisible) {\n            this.resetCropperPosition();\n        }\n    }\n\n    private initCropper() {\n        this.imageVisible = false;\n        this.originalImage = null;\n        this.safeImgDataUrl = 'data:image/png;base64,iVBORw0KGg'\n            + 'oAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAU'\n            + 'AAarVyFEAAAAASUVORK5CYII=';\n        this.moveStart = {\n            active: false,\n            type: null,\n            position: null,\n            x1: 0,\n            y1: 0,\n            x2: 0,\n            y2: 0,\n            clientX: 0,\n            clientY: 0\n        };\n        this.maxSize = {\n            width: 0,\n            height: 0\n        };\n        this.originalSize = {\n            width: 0,\n            height: 0\n        };\n        this.cropper.x1 = -100;\n        this.cropper.y1 = -100;\n        this.cropper.x2 = 10000;\n        this.cropper.y2 = 10000;\n    }\n\n    private loadImageFile(file: File) {\n        const fileReader = new FileReader();\n        fileReader.onload = (event: any) => {\n            const imageType = file.type;\n            if (this.isValidImageType(imageType)) {\n                resetExifOrientation(event.target.result)\n                    .then((resultBase64: string) => this.loadBase64Image(resultBase64))\n                    .catch(() => this.loadImageFailed.emit());\n            } else {\n                this.loadImageFailed.emit();\n            }\n        };\n        fileReader.readAsDataURL(file);\n    }\n\n    private isValidImageType(type: string) {\n        return /image\\/(png|jpg|jpeg|bmp|gif|tiff)/.test(type);\n    }\n\n    private loadBase64Image(imageBase64: string) {\n        this.safeImgDataUrl = this.sanitizer.bypassSecurityTrustResourceUrl(imageBase64);\n        this.originalImage = new Image();\n        this.originalImage.onload = () => {\n            this.originalSize.width = this.originalImage.width;\n            this.originalSize.height = this.originalImage.height;\n            this.cd.markForCheck();\n        };\n        this.originalImage.src = imageBase64;\n    }\n\n    imageLoadedInView(): void {\n        if (this.originalImage != null) {\n            this.imageLoaded.emit();\n            setTimeout(() => {\n                this.setMaxSize();\n                this.resetCropperPosition();\n                this.cd.markForCheck();\n            });\n        }\n    }\n\n    @HostListener('window:resize')\n    onResize() {\n        this.resizeCropperPosition();\n        this.setMaxSize();\n    }\n\n    private resizeCropperPosition() {\n        const sourceImageElement = this.sourceImage.nativeElement;\n        if (this.maxSize.width !== sourceImageElement.offsetWidth || this.maxSize.height !== sourceImageElement.offsetHeight) {\n            this.cropper.x1 = this.cropper.x1 * sourceImageElement.offsetWidth / this.maxSize.width;\n            this.cropper.x2 = this.cropper.x2 * sourceImageElement.offsetWidth / this.maxSize.width;\n            this.cropper.y1 = this.cropper.y1 * sourceImageElement.offsetHeight / this.maxSize.height;\n            this.cropper.y2 = this.cropper.y2 * sourceImageElement.offsetHeight / this.maxSize.height;\n        }\n    }\n\n    private resetCropperPosition() {\n        const sourceImageElement = this.sourceImage.nativeElement;\n        if (sourceImageElement.offsetWidth / this.aspectRatio < sourceImageElement.offsetHeight) {\n            this.cropper.x1 = 0;\n            this.cropper.x2 = sourceImageElement.offsetWidth;\n            const cropperHeight = sourceImageElement.offsetWidth / this.aspectRatio;\n            this.cropper.y1 = (sourceImageElement.offsetHeight - cropperHeight) / 2;\n            this.cropper.y2 = this.cropper.y1 + cropperHeight;\n        } else {\n            this.cropper.y1 = 0;\n            this.cropper.y2 = sourceImageElement.offsetHeight;\n            const cropperWidth = sourceImageElement.offsetHeight * this.aspectRatio;\n            this.cropper.x1 = (sourceImageElement.offsetWidth - cropperWidth) / 2;\n            this.cropper.x2 = this.cropper.x1 + cropperWidth;\n        }\n        this.doAutoCrop();\n        this.imageVisible = true;\n    }\n\n    startMove(event: any, moveType: string, position: string | null = null) {\n        this.moveStart = Object.assign({\n            active: true,\n            type: moveType,\n            position: position,\n            clientX: this.getClientX(event),\n            clientY: this.getClientY(event)\n        }, this.cropper);\n    }\n\n    @HostListener('document:mousemove', ['$event'])\n    @HostListener('document:touchmove', ['$event'])\n    moveImg(event: any) {\n        if (this.moveStart.active) {\n            event.stopPropagation();\n            event.preventDefault();\n            this.setMaxSize();\n            if (this.moveStart.type === 'move') {\n                this.move(event);\n                this.checkCropperPosition(true);\n            } else if (this.moveStart.type === 'resize') {\n                this.resize(event);\n                this.checkCropperPosition(false);\n            }\n            this.cd.detectChanges();\n        }\n    }\n\n    private setMaxSize() {\n        const sourceImageElement = this.sourceImage.nativeElement;\n        this.maxSize.width = sourceImageElement.offsetWidth;\n        this.maxSize.height = sourceImageElement.offsetHeight;\n        this.marginLeft = this.sanitizer.bypassSecurityTrustStyle('calc(50% - ' + this.maxSize.width / 2 + 'px)');\n    }\n\n    private checkCropperPosition(maintainSize = false) {\n        if (this.cropper.x1 < 0) {\n            this.cropper.x2 -= maintainSize ? this.cropper.x1 : 0;\n            this.cropper.x1 = 0;\n        }\n        if (this.cropper.y1 < 0) {\n            this.cropper.y2 -= maintainSize ? this.cropper.y1 : 0;\n            this.cropper.y1 = 0;\n        }\n        if (this.cropper.x2 > this.maxSize.width) {\n            this.cropper.x1 -= maintainSize ? (this.cropper.x2 - this.maxSize.width) : 0;\n            this.cropper.x2 = this.maxSize.width;\n        }\n        if (this.cropper.y2 > this.maxSize.height) {\n            this.cropper.y1 -= maintainSize ? (this.cropper.y2 - this.maxSize.height) : 0;\n            this.cropper.y2 = this.maxSize.height;\n        }\n    }\n\n    @HostListener('document:mouseup')\n    @HostListener('document:touchend')\n    moveStop() {\n        if (this.moveStart.active) {\n            this.moveStart.active = false;\n            this.doAutoCrop();\n        }\n    }\n\n    private move(event: any) {\n        const diffX = this.getClientX(event) - this.moveStart.clientX;\n        const diffY = this.getClientY(event) - this.moveStart.clientY;\n\n        this.cropper.x1 = this.moveStart.x1 + diffX;\n        this.cropper.y1 = this.moveStart.y1 + diffY;\n        this.cropper.x2 = this.moveStart.x2 + diffX;\n        this.cropper.y2 = this.moveStart.y2 + diffY;\n    }\n\n    private resize(event: any) {\n        const diffX = this.getClientX(event) - this.moveStart.clientX;\n        const diffY = this.getClientY(event) - this.moveStart.clientY;\n        switch (this.moveStart.position) {\n            case 'left':\n                this.cropper.x1 = Math.min(this.moveStart.x1 + diffX, this.cropper.x2 - 20);\n                break;\n            case 'topleft':\n                this.cropper.x1 = Math.min(this.moveStart.x1 + diffX, this.cropper.x2 - 20);\n                this.cropper.y1 = Math.min(this.moveStart.y1 + diffY, this.cropper.y2 - 20);\n                break;\n            case 'top':\n                this.cropper.y1 = Math.min(this.moveStart.y1 + diffY, this.cropper.y2 - 20);\n                break;\n            case 'topright':\n                this.cropper.x2 = Math.max(this.moveStart.x2 + diffX, this.cropper.x1 + 20);\n                this.cropper.y1 = Math.min(this.moveStart.y1 + diffY, this.cropper.y2 - 20);\n                break;\n            case 'right':\n                this.cropper.x2 = Math.max(this.moveStart.x2 + diffX, this.cropper.x1 + 20);\n                break;\n            case 'bottomright':\n                this.cropper.x2 = Math.max(this.moveStart.x2 + diffX, this.cropper.x1 + 20);\n                this.cropper.y2 = Math.max(this.moveStart.y2 + diffY, this.cropper.y1 + 20);\n                break;\n            case 'bottom':\n                this.cropper.y2 = Math.max(this.moveStart.y2 + diffY, this.cropper.y1 + 20);\n                break;\n            case 'bottomleft':\n                this.cropper.x1 = Math.min(this.moveStart.x1 + diffX, this.cropper.x2 - 20);\n                this.cropper.y2 = Math.max(this.moveStart.y2 + diffY, this.cropper.y1 + 20);\n                break;\n        }\n\n        if (this.maintainAspectRatio) {\n            this.checkAspectRatio();\n        }\n    }\n\n    private checkAspectRatio() {\n        let overflowX = 0;\n        let overflowY = 0;\n\n        switch (this.moveStart.position) {\n            case 'top':\n                this.cropper.x2 = this.cropper.x1 + (this.cropper.y2 - this.cropper.y1) * this.aspectRatio;\n                overflowX = Math.max(this.cropper.x2 - this.maxSize.width, 0);\n                overflowY = Math.max(0 - this.cropper.y1, 0);\n                if (overflowX > 0 || overflowY > 0) {\n                    this.cropper.x2 -= (overflowY * this.aspectRatio) > overflowX ? (overflowY * this.aspectRatio) : overflowX;\n                    this.cropper.y1 += (overflowY * this.aspectRatio) > overflowX ? overflowY : overflowX / this.aspectRatio;\n                }\n                break;\n            case 'bottom':\n                this.cropper.x2 = this.cropper.x1 + (this.cropper.y2 - this.cropper.y1) * this.aspectRatio;\n                overflowX = Math.max(this.cropper.x2 - this.maxSize.width, 0);\n                overflowY = Math.max(this.cropper.y2 - this.maxSize.height, 0);\n                if (overflowX > 0 || overflowY > 0) {\n                    this.cropper.x2 -= (overflowY * this.aspectRatio) > overflowX ? (overflowY * this.aspectRatio) : overflowX;\n                    this.cropper.y2 -= (overflowY * this.aspectRatio) > overflowX ? overflowY : (overflowX / this.aspectRatio);\n                }\n                break;\n            case 'topleft':\n                this.cropper.y1 = this.cropper.y2 - (this.cropper.x2 - this.cropper.x1) / this.aspectRatio;\n                overflowX = Math.max(0 - this.cropper.x1, 0);\n                overflowY = Math.max(0 - this.cropper.y1, 0);\n                if (overflowX > 0 || overflowY > 0) {\n                    this.cropper.x1 += (overflowY * this.aspectRatio) > overflowX ? (overflowY * this.aspectRatio) : overflowX;\n                    this.cropper.y1 += (overflowY * this.aspectRatio) > overflowX ? overflowY : overflowX / this.aspectRatio;\n                }\n                break;\n            case 'topright':\n                this.cropper.y1 = this.cropper.y2 - (this.cropper.x2 - this.cropper.x1) / this.aspectRatio;\n                overflowX = Math.max(this.cropper.x2 - this.maxSize.width, 0);\n                overflowY = Math.max(0 - this.cropper.y1, 0);\n                if (overflowX > 0 || overflowY > 0) {\n                    this.cropper.x2 -= (overflowY * this.aspectRatio) > overflowX ? (overflowY * this.aspectRatio) : overflowX;\n                    this.cropper.y1 += (overflowY * this.aspectRatio) > overflowX ? overflowY : overflowX / this.aspectRatio;\n                }\n                break;\n            case 'right':\n            case 'bottomright':\n                this.cropper.y2 = this.cropper.y1 + (this.cropper.x2 - this.cropper.x1) / this.aspectRatio;\n                overflowX = Math.max(this.cropper.x2 - this.maxSize.width, 0);\n                overflowY = Math.max(this.cropper.y2 - this.maxSize.height, 0);\n                if (overflowX > 0 || overflowY > 0) {\n                    this.cropper.x2 -= (overflowY * this.aspectRatio) > overflowX ? (overflowY * this.aspectRatio) : overflowX;\n                    this.cropper.y2 -= (overflowY * this.aspectRatio) > overflowX ? overflowY : overflowX / this.aspectRatio;\n                }\n                break;\n            case 'left':\n            case 'bottomleft':\n                this.cropper.y2 = this.cropper.y1 + (this.cropper.x2 - this.cropper.x1) / this.aspectRatio;\n                overflowX = Math.max(0 - this.cropper.x1, 0);\n                overflowY = Math.max(this.cropper.y2 - this.maxSize.height, 0);\n                if (overflowX > 0 || overflowY > 0) {\n                    this.cropper.x1 += (overflowY * this.aspectRatio) > overflowX ? (overflowY * this.aspectRatio) : overflowX;\n                    this.cropper.y2 -= (overflowY * this.aspectRatio) > overflowX ? overflowY : overflowX / this.aspectRatio;\n                }\n                break;\n        }\n    }\n\n    private doAutoCrop() {\n        if (this.autoCrop) {\n            this.crop();\n        }\n    }\n\n    crop(): ImageCroppedEvent | Promise<ImageCroppedEvent> | null {\n        const sourceImageElement = this.sourceImage.nativeElement;\n        if (sourceImageElement && this.originalImage != null) {\n            this.startCropImage.emit();\n            const ratio = this.originalSize.width / sourceImageElement.offsetWidth;\n            const left = Math.round(this.cropper.x1 * ratio);\n            const top = Math.round(this.cropper.y1 * ratio);\n            const width = Math.min(Math.round((this.cropper.x2 - this.cropper.x1) * ratio), this.originalSize.width - left);\n            const height = Math.min(Math.round((this.cropper.y2 - this.cropper.y1) * ratio), this.originalSize.height - top);\n            const resizeRatio = this.getResizeRatio(width);\n            const resizedWidth = Math.floor(width * resizeRatio);\n            const resizedHeight = Math.floor(height * resizeRatio);\n\n            const cropCanvas = document.createElement('canvas') as HTMLCanvasElement;\n            cropCanvas.width = resizedWidth;\n            cropCanvas.height = resizedHeight;\n\n            const ctx = cropCanvas.getContext('2d');\n            if (ctx) {\n                ctx.drawImage(this.originalImage, left, top, width, height, 0, 0, resizedWidth, resizedHeight);\n                return this.cropToOutputType(cropCanvas, resizedWidth, resizedHeight);\n            }\n        }\n        return null;\n    }\n\n    private cropToOutputType(cropCanvas: HTMLCanvasElement, resizedWidth: number, resizedHeight: number): ImageCroppedEvent | Promise<ImageCroppedEvent> {\n        const output: ImageCroppedEvent = {\n            width: resizedWidth,\n            height: resizedHeight,\n            cropperPosition: Object.assign({}, this.cropper)\n        };\n        switch (this.outputType) {\n            case 'file':\n                return this.cropToFile(cropCanvas)\n                    .then((result: Blob | null) => {\n                        output.file = result;\n                        this.imageCropped.emit(output);\n                        return output;\n                    });\n            case 'both':\n                output.base64 = this.cropToBase64(cropCanvas);\n                return this.cropToFile(cropCanvas)\n                    .then((result: Blob | null) => {\n                        output.file = result;\n                        this.imageCropped.emit(output);\n                        return output;\n                    });\n            default:\n                output.base64 = this.cropToBase64(cropCanvas);\n                this.imageCropped.emit(output);\n                return output;\n        }\n    }\n\n    private cropToBase64(cropCanvas: HTMLCanvasElement): string {\n        const imageBase64 = cropCanvas.toDataURL('image/' + this.format, this.getQuality());\n        this.imageCroppedBase64.emit(imageBase64);\n        return imageBase64;\n    }\n\n    private cropToFile(cropCanvas: HTMLCanvasElement): Promise<Blob | null> {\n        return this.getCanvasBlob(cropCanvas)\n            .then((result: Blob | null) => {\n                if (result) {\n                    this.imageCroppedFile.emit(result);\n                }\n                return result;\n            });\n    }\n\n    private getCanvasBlob(cropCanvas: HTMLCanvasElement): Promise<Blob | null> {\n        return new Promise((resolve) => {\n            cropCanvas.toBlob(\n                (result: Blob | null) => this.zone.run(() => resolve(result)),\n                'image/' + this.format,\n                this.getQuality()\n            );\n        });\n    }\n\n    private getQuality(): number {\n        return Math.min(1, Math.max(0, this.imageQuality / 100));\n    }\n\n    private getResizeRatio(width: number): number {\n        return this.resizeToWidth > 0 && (!this.onlyScaleDown || width > this.resizeToWidth)\n            ? this.resizeToWidth / width\n            : 1;\n    }\n\n    private getClientX(event: any) {\n        return event.clientX != null ? event.clientX : event.touches[0].clientX;\n    }\n\n    private getClientY(event: any) {\n        return event.clientY != null ? event.clientY : event.touches[0].clientY;\n    }\n}\n","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { ImageCropperComponent } from './component/image-cropper.component';\n\n@NgModule({\n    imports: [\n        CommonModule\n    ],\n    declarations: [\n        ImageCropperComponent\n    ],\n    exports: [\n        ImageCropperComponent\n    ]\n})\nexport class ImageCropperModule {}\n"]}